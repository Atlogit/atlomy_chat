name: Production Deployment to EC2

on:
  workflow_run:
    workflows: ["Docker Build and Registry Push"]
    types:
      - completed
    branches:
      - production
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deployment without Docker Build workflow'
        required: false
        type: boolean
        default: false

# Comprehensive permissions for GitHub Actions workflow
permissions:
  contents: read
  packages: read
  id-token: write

jobs:
  # Initial debug and context verification step
  debug-workflow-trigger:
    runs-on: ubuntu-latest
    if: ${{ always() }}
    steps:
      - name: Detailed Workflow Trigger Debug
        env:
          GITHUB_CONTEXT: ${{ toJson(github) }}
          WORKFLOW_RUN: ${{ toJson(github.event.workflow_run) }}
        run: |
          echo "=== Workflow Trigger Debug Information ==="
          echo "Event Name: ${{ github.event_name }}"
          echo "Workflow Run Conclusion: ${{ github.event.workflow_run.conclusion }}"
          echo "Workflow Run Name: ${{ github.event.workflow_run.name }}"
          echo "Head Branch: ${{ github.event.workflow_run.head_branch }}"
          echo "Triggering Workflow ID: ${{ github.event.workflow_run.id }}"
          echo "Triggering Workflow URL: ${{ github.event.workflow_run.html_url }}"

  # Primary deployment job
  deploy-to-ec2:
    needs: debug-workflow-trigger
    # Conditional execution based on workflow trigger or manual dispatch
    if: |
      (github.event_name == 'workflow_dispatch') ||
      (github.event.workflow_run.conclusion == 'success' && 
       github.event.workflow_run.name == 'Docker Build and Registry Push' &&
       (github.event.workflow_run.head_branch == 'production' || 
        contains(github.event.workflow_run.head_branch, 'production')))
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: read
      id-token: write

    steps:
      # Repository checkout with explicit production branch reference
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: production
          fetch-depth: 0

      # Verbose file system debugging to ensure correct context
      - name: Verbose File System Debug
        run: |
          pwd
          echo "=== Repository Root Contents ==="
          ls -la
          echo "=== Dockerfile Contents ==="
          cat Dockerfile || echo "Dockerfile not found"
          echo "=== Full Directory Tree ==="
          find . -type f | sort

      # Explicit Dockerfile presence verification
      - name: Verify Dockerfile Presence
        run: |
          if [ ! -f Dockerfile ]; then
            echo "Critical Error: Dockerfile is missing!"
            exit 1
          fi
          echo "Dockerfile verified successfully"

      # GitHub Container Registry authentication using GitHub Token
      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Docker image pull with explicit repository name transformation
      - name: Pull latest Docker image from GitHub Registry
        run: |
          REPO_LOWER=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
          echo "Pulling image for repository: $REPO_LOWER"
          docker pull ghcr.io/$REPO_LOWER:production

      # Remaining workflow steps (Python setup, AWS credentials, etc.)
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install boto3 botocore awscli

      # AWS OIDC credential configuration
      - name: Configure AWS Credentials with OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_OIDC_ROLE_ARN }}
          aws-region: us-east-1

      # Secrets retrieval from AWS Secrets Manager
      - name: Retrieve Production Secrets from AWS Secrets Manager
        id: get-secrets
        run: |
          secrets=$(aws secretsmanager get-secret-value --secret-id amta-production-secrets --query SecretString --output text)
          
          redis_url=$(echo $secrets | jq -r '.REDIS_URL')
          bedrock_model_id=$(echo $secrets | jq -r '.BEDROCK_MODEL_ID')
          
          echo "::add-mask::$redis_url"
          echo "::add-mask::$bedrock_model_id"
          
          echo "REDIS_URL=$redis_url" >> $GITHUB_OUTPUT
          echo "BEDROCK_MODEL_ID=$bedrock_model_id" >> $GITHUB_OUTPUT

      # Deployment configuration preparation
      - name: Prepare deployment configuration
        env:
          REDIS_URL: ${{ steps.get-secrets.outputs.REDIS_URL }}
          BEDROCK_MODEL_ID: ${{ steps.get-secrets.outputs.BEDROCK_MODEL_ID }}
        run: |
          mkdir -p ./deploy_config
          echo "DEPLOYMENT_MODE=production" > ./deploy_config/deployment.env
          echo "REDIS_URL=$REDIS_URL" >> ./deploy_config/deployment.env
          echo "BEDROCK_MODEL_ID=$BEDROCK_MODEL_ID" >> ./deploy_config/deployment.env
          chmod 600 ./deploy_config/deployment.env

      # Configuration validation
      - name: Run configuration validator
        run: |
          python config_validator.py .env.production
        env:
          DEPLOYMENT_MODE: production
          AWS_DEFAULT_REGION: us-east-1

      # EC2 deployment via SSH
      - name: Deploy to EC2 via SSH
        env:
          EC2_SSH_KEY: ${{ secrets.EC2_SSH_PRIVATE_KEY }}
          EC2_HOST: ${{ secrets.EC2_HOST }}
          EC2_USER: ${{ secrets.EC2_USER }}
          REDIS_URL: ${{ steps.get-secrets.outputs.REDIS_URL }}
          BEDROCK_MODEL_ID: ${{ steps.get-secrets.outputs.BEDROCK_MODEL_ID }}
        run: |
          # Debugging SSH Connection
          echo "Attempting to deploy to $EC2_HOST as $EC2_USER"
          
          # Prepare SSH Key
          mkdir -p /home/ec2-user/.ssh
          echo "$EC2_SSH_KEY" > /home/ec2-user/.ssh/ec2_key
          chmod 600 /home/ec2-user/.ssh/ec2_key
          
          # Add Host Key Scanning
          ssh-keyscan -H $EC2_HOST >> /home/ec2-user/.ssh/known_hosts 2>/dev/null
          
          # Verbose SSH Connection Test
          ssh -vv -T -o StrictHostKeyChecking=no -i /home/ec2-user/.ssh/ec2_key $EC2_USER@$EC2_HOST << SSH_TEST
            echo "SSH Connection Successful"
            pwd
            whoami
          SSH_TEST
          
          # Deployment Commands
          ssh -T -o StrictHostKeyChecking=no -i /home/ec2-user/.ssh/ec2_key $EC2_USER@$EC2_HOST << DEPLOY_COMMANDS
            # Create Project Directory
            mkdir -p /home/ec2-user/atlomy_chat
            chmod 750 /home/ec2-user/atlomy_chat
          SETUP_EOF

          # Securely copy deployment files
          scp -o StrictHostKeyChecking=no -i /home/ec2-user/.ssh/ec2_key \
              ./deploy_config/deployment.env \
              $EC2_USER@$EC2_HOST:/home/ec2-user/atlomy_chat/.env

          scp -o StrictHostKeyChecking=no -i /home/ec2-user/.ssh/ec2_key \
              docker-compose.yml \
              $EC2_USER@$EC2_HOST:/home/ec2-user/atlomy_chat/docker-compose.yml

          # Enhanced deployment script
          ssh -o StrictHostKeyChecking=no -i /home/ec2-user/.ssh/ec2_key $EC2_USER@$EC2_HOST << DEPLOY_EOF
            cd /home/ec2-user/atlomy_chat
            
            # Deployment Logging
            echo "Deployment initiated at \$(date)" > deployment.log
            
            # Pull Latest Docker Image
            docker pull ghcr.io/$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]'):production
            
            # Restart Containers
            docker-compose down
            docker-compose up -d
            
            # Log Container Status
            docker-compose ps
            docker-compose logs --tail=50
          DEPLOY_COMMANDS
          
          # Capture SSH Exit Code
          ssh_exit_code=$?
          if [ $ssh_exit_code -ne 0 ]; then
            echo "SSH Deployment Failed with Exit Code: $ssh_exit_code"
            exit $ssh_exit_code
          fi

      # Health Verification
      - name: Verify Deployment Health
        env:
          EC2_SSH_KEY: ${{ secrets.EC2_SSH_PRIVATE_KEY }}
          EC2_HOST: ${{ secrets.EC2_HOST }}
          EC2_USER: ${{ secrets.EC2_USER }}
        run: |
          # Health Check via SSH
          ssh -T -o StrictHostKeyChecking=no -i /home/ec2-user/.ssh/ec2_key $EC2_USER@$EC2_HOST << HEALTH_CHECK
            cd /home/ec2-user/atlomy_chat
            
            # Retry Mechanism for Health Check
            max_attempts=5
            attempt=0
            
            while [ \$attempt -lt \$max_attempts ]; do
              echo "Health Check Attempt \$((attempt + 1))"
              
              # Comprehensive Health Check
              health_response=$(curl -s -w "%{http_code}" http://localhost:8081/health)
              http_status=\${health_response: -3}
              
              if [ "\$http_status" = "200" ]; then
                echo "Successful Health Check: Application is Operational"
                exit 0
              fi
              
              echo "Health Check Failed. Status Code: \$http_status"
              
              # Container Logs for Debugging
              docker-compose logs --tail=50
              
              attempt=\$((attempt + 1))
              sleep 15
            done
            
            echo "Critical: Health Checks Failed After \$max_attempts Attempts"
            exit 1
          HEALTH_CHECK
