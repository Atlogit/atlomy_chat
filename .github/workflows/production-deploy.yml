name: Production Deployment Workflow

on:
  workflow_dispatch:
    inputs:
      deployment_mode:
        description: 'Deployment mode (development/production)'
        required: false
        default: 'production'
        type: choice
        options:
          - production
          - development
      force_deploy:
        description: 'Force deployment without Docker Build workflow'
        required: false
        type: boolean
        default: false
  workflow_run:
    workflows: ["Docker Build and Registry Push"]
    types:
      - completed
    branches:
      - production

# Comprehensive permissions for GitHub Actions workflow
permissions:
  contents: read
  packages: read
  id-token: write

env:
  BACKEND_IMAGE_NAME: ${{ github.repository }}-backend
  FRONTEND_IMAGE_NAME: ${{ github.repository }}-frontend

jobs:
  validate-workflow-trigger:
    runs-on: ubuntu-latest
    steps:
      - name: Validate Workflow Trigger
        run: |
          echo "üîç Workflow Trigger Analysis:"
          echo "Event Name: ${{ github.event_name }}"
          echo "Workflow Run Conclusion: ${{ github.event.workflow_run.conclusion }}"
          echo "Workflow Run Name: ${{ github.event.workflow_run.name }}"
          echo "Workflow Run Branch: ${{ github.event.workflow_run.head_branch }}"

  database-restoration:
    needs: validate-workflow-trigger
    uses: ./.github/workflows/database-restoration.yml
    secrets: inherit
    with:
      deployment_mode: production

  #database-validation:
  #  needs: database-restoration
  #  uses: ./.github/workflows/database-validation.yml
  #  secrets: inherit
  #  with:
  #    deployment_mode: production

  deploy-to-ec2:
    needs: 
      - database-restoration
    runs-on: ubuntu-latest
    environment: ${{ inputs.deployment_mode }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          ref: production
          fetch-depth: 0

      - name: Prepare Deployment Logs
        run: |
          mkdir -p deployment_logs
          chmod 777 deployment_logs
          echo "Workflow initiated at $(date)" > deployment_logs/workflow_start.log
          echo "Repository: ${{ github.repository }}" >> deployment_logs/workflow_start.log
          echo "Workflow Run ID: ${{ github.run_id }}" >> deployment_logs/workflow_start.log
          ls -la deployment_logs

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_OIDC_ROLE_ARN }}
          aws-region: us-east-1

      - name: Retrieve Production Secrets
        id: get-secrets
        run: |
          secrets=$(aws secretsmanager get-secret-value --secret-id amta-production-secrets --query SecretString --output text)
          
          # Comprehensive secret extraction
          database_url=$(echo "$secrets" | jq -r '.DATABASE_URL')
          
          # Validate database URL
          if [ -z "$database_url" ]; then
            echo "‚ùå DATABASE_URL not found in secrets"
            exit 1
          fi
          
          # Extract database connection parameters using dynamic parsing
          postgres_host=$(echo "$database_url" | sed -E 's|postgresql\+asyncpg://[^:]+:[^@]+@([^:/]+).*|\1|')
          postgres_port=$(echo "$database_url" | sed -E 's|postgresql\+asyncpg://[^:]+:[^@]+@[^:/]+:?([0-9]+)?.*|\1|' || echo "5432")
          postgres_db=$(echo "$database_url" | sed -E 's|postgresql\+asyncpg://[^:]+:[^@]+@[^:/]+:?[0-9]*/([^?]+).*|\1|')
          postgres_user=$(echo "$database_url" | sed -E 's|postgresql\+asyncpg://([^:]+):.*|\1|')
          postgres_password=$(echo "$secrets" | jq -r '.POSTGRES_PASSWORD')
          
          # Validate extracted components
          for var in postgres_host postgres_db postgres_user postgres_password; do
            if [ -z "${!var}" ]; then
              echo "‚ùå Failed to extract $var from DATABASE_URL"
              exit 1
            fi
          done
          
          # Additional secrets extraction
          redis_url=$(echo "$secrets" | jq -r '.REDIS_URL')
          redis_host=$(echo "$secrets" | jq -r '.REDIS_HOST')
          redis_port=$(echo "$secrets" | jq -r '.REDIS_PORT')
          redis_db=$(echo "$secrets" | jq -r '.REDIS_DB')
          redis_password=$(echo "$secrets" | jq -r '.REDIS_PASSWORD')
          
          bedrock_model_id=$(echo "$secrets" | jq -r '.BEDROCK_MODEL_ID')
          aws_bedrock_region=$(echo "$secrets" | jq -r '.AWS_BEDROCK_REGION')
          
          # Mask sensitive values
          echo "::add-mask::$database_url"
          echo "::add-mask::$postgres_host"
          echo "::add-mask::$postgres_port"
          echo "::add-mask::$postgres_db"
          echo "::add-mask::$postgres_user"
          echo "::add-mask::$postgres_password"
          
          # Output to GitHub Actions environment
          echo "DATABASE_URL=$database_url" >> $GITHUB_OUTPUT
          echo "POSTGRES_HOST=$postgres_host" >> $GITHUB_OUTPUT
          echo "POSTGRES_PORT=$postgres_port" >> $GITHUB_OUTPUT
          echo "POSTGRES_DB=$postgres_db" >> $GITHUB_OUTPUT
          echo "POSTGRES_USER=$postgres_user" >> $GITHUB_OUTPUT
          echo "POSTGRES_PASSWORD=$postgres_password" >> $GITHUB_OUTPUT
          
          echo "REDIS_URL=$redis_url" >> $GITHUB_OUTPUT
          echo "REDIS_HOST=$redis_host" >> $GITHUB_OUTPUT
          echo "REDIS_PORT=$redis_port" >> $GITHUB_OUTPUT
          echo "REDIS_DB=$redis_db" >> $GITHUB_OUTPUT
          echo "REDIS_PASSWORD=$redis_password" >> $GITHUB_OUTPUT
          
          echo "BEDROCK_MODEL_ID=$bedrock_model_id" >> $GITHUB_OUTPUT
          echo "AWS_BEDROCK_REGION=$aws_bedrock_region" >> $GITHUB_OUTPUT

      - name: Prepare Deployment Configuration
        env:
          # Secrets from AWS
          DATABASE_URL: ${{ steps.get-secrets.outputs.DATABASE_URL }}
          POSTGRES_HOST: ${{ steps.get-secrets.outputs.POSTGRES_HOST }}
          POSTGRES_PORT: ${{ steps.get-secrets.outputs.POSTGRES_PORT }}
          POSTGRES_DB: ${{ steps.get-secrets.outputs.POSTGRES_DB }}
          POSTGRES_USER: ${{ steps.get-secrets.outputs.POSTGRES_USER }}
          POSTGRES_PASSWORD: ${{ steps.get-secrets.outputs.POSTGRES_PASSWORD }}
          
          REDIS_URL: ${{ steps.get-secrets.outputs.REDIS_URL }}
          REDIS_HOST: ${{ steps.get-secrets.outputs.REDIS_HOST }}
          REDIS_PORT: ${{ steps.get-secrets.outputs.REDIS_PORT }}
          REDIS_DB: ${{ steps.get-secrets.outputs.REDIS_DB }}
          REDIS_PASSWORD: ${{ steps.get-secrets.outputs.REDIS_PASSWORD }}
          
          BEDROCK_MODEL_ID: ${{ steps.get-secrets.outputs.BEDROCK_MODEL_ID }}
          AWS_BEDROCK_REGION: ${{ steps.get-secrets.outputs.AWS_BEDROCK_REGION }}
        run: |
          # Start with .env.example as base configuration
          cp .env.example .env
          
          # Override .env with secret values, preserving other parameters
          sed -i "s|^DATABASE_URL=.*|DATABASE_URL=$DATABASE_URL|" .env
          sed -i "s|^POSTGRES_HOST=.*|POSTGRES_HOST=$POSTGRES_HOST|" .env
          sed -i "s|^POSTGRES_PORT=.*|POSTGRES_PORT=$POSTGRES_PORT|" .env
          sed -i "s|^POSTGRES_DB=.*|POSTGRES_DB=$POSTGRES_DB|" .env
          sed -i "s|^POSTGRES_USER=.*|POSTGRES_USER=$POSTGRES_USER|" .env
          sed -i "s|^POSTGRES_PASSWORD=.*|POSTGRES_PASSWORD=$POSTGRES_PASSWORD|" .env
          
          sed -i "s|^REDIS_URL=.*|REDIS_URL=$REDIS_URL|" .env
          sed -i "s|^REDIS_HOST=.*|REDIS_HOST=$REDIS_HOST|" .env
          sed -i "s|^REDIS_PORT=.*|REDIS_PORT=$REDIS_PORT|" .env
          sed -i "s|^REDIS_DB=.*|REDIS_DB=$REDIS_DB|" .env
          sed -i "s|^REDIS_PASSWORD=.*|REDIS_PASSWORD=$REDIS_PASSWORD|" .env
          
          sed -i "s|^BEDROCK_MODEL_ID=.*|BEDROCK_MODEL_ID=$BEDROCK_MODEL_ID|" .env
          sed -i "s|^AWS_BEDROCK_REGION=.*|AWS_BEDROCK_REGION=$AWS_BEDROCK_REGION|" .env

          # Additional Fixed Configuration
          sed -i "s|^DEPLOYMENT_MODE=.*|DEPLOYMENT_MODE=production|" .env
          sed -i "s|^AWS_REGION=.*|AWS_REGION=us-east-1|" .env
          sed -i "s|^SERVER_HOST=.*|SERVER_HOST=0.0.0.0|" .env
          sed -i "s|^SERVER_PORT=.*|SERVER_PORT=8081|" .env
          
          # Secure .env file permissions
          chmod 600 .env

          # Validate .env file creation
          if [ ! -f .env ]; then
            cp .env.example .env
            echo "Created .env file from .env.example"
          fi

          # Run configuration validator
          python config_validator.py .env
          
      - name: Deploy to EC2
        env:
          EC2_SSH_KEY: ${{ secrets.EC2_SSH_PRIVATE_KEY }}
          EC2_HOST: ${{ secrets.EC2_HOST }}
          EC2_USER: ${{ secrets.EC2_USER }}
        run: |
          mkdir -p ~/.ssh
          echo "$EC2_SSH_KEY" > ~/.ssh/ec2_key
          chmod 600 ~/.ssh/ec2_key

          SSH_OPTS="-o BatchMode=yes -o StrictHostKeyChecking=no"

          # Setup EC2 environment
          ssh $SSH_OPTS -i ~/.ssh/ec2_key $EC2_USER@$EC2_HOST << SETUP_EOF
            HOME_DIR=\$(eval echo ~$EC2_USER)
            mkdir -p \$HOME_DIR/atlomy_chat/logs
            chmod 750 \$HOME_DIR/atlomy_chat/logs
            echo "Deployment initiated at \$(date)" > \$HOME_DIR/atlomy_chat/logs/deployment.log
          SETUP_EOF

          # Copy deployment files
          scp $SSH_OPTS -i ~/.ssh/ec2_key \
              docker-compose.yml .env \
              $EC2_USER@$EC2_HOST:~/atlomy_chat/

          # Deploy services using Docker Compose
          ssh $SSH_OPTS -i ~/.ssh/ec2_key $EC2_USER@$EC2_HOST << DEPLOY_EOF
            HOME_DIR=\$(eval echo ~$EC2_USER)
            cd \$HOME_DIR/atlomy_chat
            
            # Pull latest images
            docker-compose pull
            
            # Stop and remove existing containers
            docker-compose down || true
            
            # Start new deployment
            docker-compose up -d
            
            # Log container status
            docker-compose ps
            docker-compose logs --tail=100
          DEPLOY_EOF

      - name: Verify Deployment
        run: |
          # Run comprehensive deployment verification
          ./verify_deployment.sh

      - name: Verify Deployment Health
        env:
          EC2_SSH_KEY: ${{ secrets.EC2_SSH_PRIVATE_KEY }}
          EC2_HOST: ${{ secrets.EC2_HOST }}
          EC2_USER: ${{ secrets.EC2_USER }}
        run: |
          SSH_OPTS="-o BatchMode=yes -o StrictHostKeyChecking=no"
          
          ssh $SSH_OPTS -i ~/.ssh/ec2_key $EC2_USER@$EC2_HOST << HEALTH_EOF
            HOME_DIR=\$(eval echo ~$EC2_USER)
            cd \$HOME_DIR/atlomy_chat
            
            max_attempts=3
            attempt=0
            
            while [ \$attempt -lt \$max_attempts ]; do
              echo "Health Check Attempt \$((attempt + 1))"
              
              backend_response=\$(curl -s -w "%{http_code}" http://localhost:8081/health)
              frontend_response=\$(curl -s -w "%{http_code}" http://localhost:3000)
              
              backend_status=\${backend_response: -3}
              frontend_status=\${frontend_response: -3}
              
              if [ "\$backend_status" = "200" ] && [ "\$frontend_status" = "200" ]; then
                echo "Successful Health Check: Both Backend and Frontend are Operational"
                exit 0
              fi
              
              echo "Health Check Failed. Backend Status: \$backend_status, Frontend Status: \$frontend_status"
              docker-compose logs --tail=100
              
              attempt=\$((attempt + 1))
              sleep 15
            done
            
            echo "Critical: Health Checks Failed After \$max_attempts Attempts"
            exit 1
          HEALTH_EOF

      - name: Preserve Deployment Logs
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: deployment-logs
          path: |
            deployment_logs/
            ${{ github.workspace }}/deployment_logs/
          retention-days: 7

      - name: Generate Fallback Logs
        if: failure()
        run: |
          mkdir -p deployment_logs
          echo "Workflow Failed" > deployment_logs/workflow_failure.log
          echo "Workflow Run ID: ${{ github.run_id }}" >> deployment_logs/workflow_failure.log
          echo "Repository: ${{ github.repository }}" >> deployment_logs/workflow_failure.log
          env >> deployment_logs/environment_vars.log

  notify-status:
    if: always()
    needs: [deploy-to-ec2]
    runs-on: ubuntu-latest
    steps:
      - name: Determine Workflow Status
        run: |
          if [[ "${{ needs.deploy-to-ec2.result }}" == "success" ]]; then
            echo "‚úÖ Production Deployment Completed Successfully"
          else
            echo "‚ùå Production Deployment Failed"
            exit 1
          fi