name: Database Restoration Workflow

on:
  workflow_dispatch:
    inputs:
      deployment_mode:
        description: 'Deployment mode (development/production)'
        required: false
        default: 'production'
      force_restore:
        description: 'Force database restoration'
        type: boolean
        default: false
      s3_backup_bucket:
        description: 'S3 Bucket for Database Backups'
        required: true
        default: 'amta-app'
      s3_backup_prefix:
        description: 'S3 Prefix for Database Backups'
        required: true
        default: 'amta-db'
  workflow_call:
    inputs:
      deployment_mode:
        description: 'Deployment mode (development/production)'
        type: string
        required: false
        default: 'production'
      force_restore:
        description: 'Force database restoration'
        type: boolean
        default: false
      s3_backup_bucket:
        description: 'S3 Bucket for Database Backups'
        type: string
        required: false
        default: 'amta-app'
      s3_backup_prefix:
        description: 'S3 Prefix for Database Backups'
        type: string
        required: false
        default: 'amta-db'

permissions:
  id-token: write
  contents: read

jobs:
  database-restoration:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_OIDC_ROLE_ARN }}
          aws-region: us-east-1

      - name: Retrieve Database Secrets
        id: get-database-secrets
        run: |
          secrets=$(aws secretsmanager get-secret-value --secret-id amta-production-secrets --query SecretString --output text)
          
          # Extract DATABASE_URL and parse host
          database_url=$(echo $secrets | jq -r '.DATABASE_URL')
          
          # Validate DATABASE_URL format
          if [[ ! "$database_url" =~ ^postgresql\+asyncpg://[^:]+:[^@]+@[^:/]+(/[^?]*)?(\?.*)?$ ]]; then
            echo "‚ùå Invalid DATABASE_URL format"
            echo "Provided URL: $database_url"
            echo "Expected format: postgresql+asyncpg://user:pass@host/database"
            exit 1
          fi
          
          # Robust URL parsing with error handling
          postgres_host=$(echo "$database_url" | sed -E 's|postgresql\+asyncpg://[^:]+:[^@]+@([^:/]+).*|\1|')
          postgres_port=$(echo "$database_url" | sed -E 's|postgresql\+asyncpg://[^:]+:[^@]+@[^:/]+:?([0-9]+)?.*|\1|' || echo "5432")
          postgres_db=$(echo "$database_url" | sed -E 's|postgresql\+asyncpg://[^:]+:[^@]+@[^:/]+:?[0-9]*/([^?]+).*|\1|')
          postgres_user=$(echo "$database_url" | sed -E 's|postgresql\+asyncpg://([^:]+):.*|\1|')
          
          # Comprehensive validation with detailed error reporting
          validation_errors=()
          
          if [[ -z "$postgres_host" || "$postgres_host" == "localhost" ]]; then
            echo "‚ö†Ô∏è Warning: Invalid or localhost host detected"
            echo "Host: $postgres_host"
          fi
          
          if [ -z "$postgres_db" ]; then
            validation_errors+=("Database name could not be parsed")
          fi
          
          if [ -z "$postgres_user" ]; then
            validation_errors+=("Username could not be parsed")
          fi
          
          if [ "${#validation_errors[@]}" -gt 0 ]; then
            echo "‚ùå Database URL parsing errors:"
            printf '%s\n' "${validation_errors[@]}"
            echo "Full URL: $database_url"
            echo "connection_status=partial_config" >> $GITHUB_OUTPUT
          else
            echo "connection_status=valid_config" >> $GITHUB_OUTPUT
          fi
          
          # Retrieve password separately to avoid potential sed parsing issues
          postgres_password=$(echo $secrets | jq -r '.POSTGRES_PASSWORD')
          
          if [ -z "$postgres_password" ]; then
            echo "‚ùå Database password could not be retrieved"
            echo "connection_status=no_password" >> $GITHUB_OUTPUT
          fi
          
          # Output parsed values
          echo "POSTGRES_HOST=$postgres_host" >> $GITHUB_OUTPUT
          echo "POSTGRES_PORT=$postgres_port" >> $GITHUB_OUTPUT
          echo "POSTGRES_DB=$postgres_db" >> $GITHUB_OUTPUT
          echo "POSTGRES_USER=$postgres_user" >> $GITHUB_OUTPUT
          echo "POSTGRES_PASSWORD=$postgres_password" >> $GITHUB_OUTPUT
          
          # Diagnostic logging
          echo "üîç Parsed Connection Details:"
          echo "  Host: $postgres_host"
          echo "  Port: $postgres_port"
          echo "  Database: $postgres_db"

      # Remaining workflow steps stay the same
      # ... [rest of the workflow content from previous version]

  notify-status:
    if: always()
    needs: [database-restoration]
    runs-on: ubuntu-latest
    steps:
      - name: Determine Workflow Status
        run: |
          if [[ "${{ needs.database-restoration.result }}" == "success" ]]; then
            echo "‚úÖ Database Backup Staging Completed Successfully"
          else
            echo "‚ùå Database Backup Staging Failed"
            exit 1
          fi
